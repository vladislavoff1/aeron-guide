# Дальнейшие улучшения

### IPv6

В настоящее время реализация, как описано, будет работать правильно по IPv6. Основная проблема заключается в том, что добавленные ограничения уровня IP \(такие как «не более 4 подключений на IP-адрес»\) неэффективны в IPv6. Ограничения IP-адресов основаны на представлении о том, что \(как и в случае с сегодняшним IPv4\) IP-адреса в дефиците, и поэтому случайный злонамеренный клиент не будет контролировать большой набор IP-адресов, которые могут использоваться для обхода ограничений доступа.

В IPv6 каждый клиент имеет доступ как минимум к 18446744073709551616 адресам. Для реализации ограничений IP-доступа необходимо будет расширить правила, чтобы исключить целые подсети.

### Фильтрация на уровне конечной точки

Текущая реализация анализирует возвращаемые строки `Image.sourceIdentity()`и действует на основе проанализированных адресов. Это несколько неприятно и, возможно, работает на неправильном уровне абстракции для программы Aeron. Например, если мы хотим взять клиентскую и серверную программу и запустить их через транспорт, который не был UDP / IP, их нужно будет переписать.

Aeron расширяется тем, что позволяет программистам предоставлять собственные _конечные точки_ . _Конечной точки_ можно рассматривать как абстракции над ресурсом , такие как UDP сокет. Aeron поставляется с рядом пользовательских реализаций _конечных точек,_ которые позволяют выполнять такие функции, как имитация потери пакетов, контроль перегрузки и многое другое. Несколько грубые ограничения уровня IP, реализованные сервером, могут быть лучше реализованы с помощью пользовательской реализации _конечной точки_ .

Смотрите [the driver extension directory](https://github.com/real-logic/aeron/tree/master/aeron-driver/src/main/java/io/aeron/driver/ext).

### Шифрование для каждого пакета

Если бы мы хотели защитить от вредоносных клиентов, которые имеют возможность чтения и / или изменения пакетов, отправленных другим клиентом \(путем подмены ARP или каким-либо другим способом\), нам нужно было бы добавить некоторую форму аутентификации и шифрования в протокол.

В настоящее время приложению необходимо будет договориться о том, чтобы клиент и сервер согласовали сеансовый ключ, а затем необходимо было бы зашифровать каждое данное сообщение `Publication.offer()`\(и, соответственно, расшифровать каждое полученное сообщение `Subscription.poll()`\). Это повлекло бы за собой значительные издержки как при большом количестве требуемых операций шифрования, так и при неизбежном заполнении каждого сообщения, необходимого для работы многих режимов алгоритма.

Надежда на горизонте, однако. На момент написания \( `2018-04-10`\) поддержка шифрования на уровне протокола была запланированной функцией в Aeron и должна устранить необходимость в криптографической обработке на уровне приложений.  


