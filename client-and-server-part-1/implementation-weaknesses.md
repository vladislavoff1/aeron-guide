# Слабые стороны реализации

#### Отключение сервера EchoClient

Реализация `EchoClient` не обрабатывает случай, когда сервер либо отключается, либо вообще не существует. Он просто попытается отправить сообщения навсегда и проигнорирует тот факт, что он никогда не получит ответ. Обработка этого была намеренно исключена из реализации ради сохранения максимально простого кода. Способ исправить это двоякий.

Во-первых, клиент может просто отказаться от попытки отправить исходное сообщение `HELLO` если по истечении разумного промежутка времени ответ не был получен. Это решение может хорошо работать для протоколов, где клиент должен отправить первое сообщение в диалоге. Aeron также указывает, когда `Publication` больше не подключена, возвращая `NOT_CONNECTED` или `CLOSED` при вызове`offer()` в `Publication` . Реальные приложения могут реагировать соответственно, а не просто регистрировать сообщение об `EchoClient` \(например, `EchoClient` и `EchoServer` \) и продолжать.

Во-вторых, клиент может указать _обработчики изображений_ в _подписке, которую_ он создает, так же, как сервер. Когда _изображение_ становится доступным, это означает, что сервер отправил сообщение и, следовательно, предположительно жив и готов общаться с клиентом. Когда _изображение_ становится недоступным, сервер больше не хочет или не может общаться с клиентом. Это может хорошо работать для протоколов, где сервер должен отправлять первое сообщение в диалоге.

#### Обработка MTU является неявной

Отправка сообщений через открытый Интернет накладывает верхнюю границу [MTU](https://ru.wikipedia.org/wiki/Maximum_transmission_unit)[,](https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com&sl=en&sp=nmt4&tl=ru&u=https://en.wikipedia.org/wiki/Maximum_transmission_unit&xid=17259,1500004,15700023,15700186,15700190,15700253,15700256,15700259&usg=ALkJrhj8Abnm-wf-hvap24UWvCezOaE_fg) которую приложение может использовать для отдельных сообщений.

Как общее практическое правило, `MTU` для пакетов UDP, отправляемых через открытый интернет, должен быть `<= 1200` байтов. Аэрон добавляет дополнительное ограничение, что значения `MTU`должны быть кратны `32` .

Реализации `EchoClient` и `EchoServer` используют строки UTF-8, `EchoServer` которых не должна превышать приблизительно `16` байтов, и поэтому предполагают, что фрагментация никогда не произойдет, и не пытаются ее избежать.

#### Клиенты, отправляющие плохие сообщения, не убиваются

`EchoServer`Реализация имеет довольно серьезный недостаток в том , что если первое сообщение , полученное клиентом не распознаваемо как простая `HELLO <port>`строка, клиент нарушителя никогда не скажут об этом , и сервере будет продолжать обрабатывать каждое последующее сообщение от клиента , как если бы была непонятная `HELLO`строка.

Отчасти это является результатом недостаточной спецификации протокола: сервер не может сообщить клиенту, что произошла фатальная ошибка и что клиент должен уйти \(или, по крайней мере, повторить попытку `HELLO`строки\). Это также проблема реализации: у сервера нет средств для принудительного отключения клиента \(и, как обсуждалось ранее, клиент не заметил бы, что он был отключен в любом случае\).

#### Ненадежная отправка сообщений

Способ отправки сообщений недостаточен в том смысле, что сбой при отправке сообщения не является серьезной ошибкой. Реальные приложения должны быть готовы поставить в очередь и при необходимости повторить сообщения, и должны выдавать исключения, если сообщения не могут быть отправлены после разумного количества попыток.

См. [Handling Back Pressure](https://github.com/real-logic/aeron/wiki/Java-Programming-Guide#handling-back-pressure) для деталей.

#### Работа на потоках Aeron

В настоящее время все работы выполняются на потоках, контролируемых Aeron. Согласно документации, `Publication`значения являются потокобезопасными, а `Subscription`значения — нет. Реальные приложения должны ожидать получения сообщений от `Subscription`и помещать их в очередь для обработки одним или несколькими потоками приложений \(шаблон, рекомендованный и для [Disruptor](https://lmax-exchange.github.io/disruptor/)\), чтобы избежать блокировки потоков проводника Aeron. Смотри [Thread Utilisation](https://github.com/real-logic/aeron/wiki/Thread-Utilisation) для деталей.

#### EchoClient не может быть позади NAT

Это наиболее серьезная проблема описанной выше реализации \(и проницательные программисты, знакомые с сетью UDP, уже заметили\): реализация принципиально несовместима с [NAT](https://ru.wikipedia.org/wiki/NAT).

Сервер должен иметь возможность открывать соединения напрямую с клиентами, а это невозможно, если клиенты не разрешают переадресацию портов на маршрутизаторах NAT, за которыми они неизбежно находятся. То же самое верно для соединений, открытых клиентами к серверу, но это не является проблемой, поскольку операторы сервера обычно включают переадресацию портов на своих маршрутизаторах, чтобы позволить клиентам подключаться. Для многопользовательской игры с нетехническими игрокам, использующим клиентов в открытом Интернете, требовать, чтобы каждый клиент включал переадресацию портов, чтобы иметь возможность подключиться к серверу, было бы неприемлемо.

Кроме того, иметь клиентов, указывающих информацию о порте в протоколе уровня приложения, неприятно. Любой, кто знаком с программированием UDP, может открыть сокет, связать его, а затем читать и записывать дейтаграммы, даже не задумываясь о NAT: маршрутизаторы будут согласовывать входящие дейтаграммы с предварительно отправленными исходящими дейтаграммами и позволять им проходить без внимания. Кажется неприятным, что Aeron потребует, чтобы мы отказались от этой функциональности на уровне ОС. К счастью, Aeron включает несколько редко документированную функцию, известную как [multi-destination-cast](https://github.com/real-logic/aeron/wiki/Protocol-Specification#multi-destination-cast-mode-of-operation)[,](https://translate.googleusercontent.com/translate_c?depth=1&rurl=translate.google.com&sl=en&sp=nmt4&tl=ru&u=https://github.com/real-logic/aeron/wiki/Protocol-Specification&xid=17259,1500004,15700023,15700186,15700190,15700253,15700256,15700259&usg=ALkJrhiFxJXnVvRlpRx3XuRgigMx28kX3g#multi-destination-cast-mode-of-operation) которая может использоваться для надежного обхода систем NAT, устраняя необходимость подключения серверов напрямую к клиентам.

