# Echo 2.0 Outline

Грубая схема нашего нового протокола заключается в том, что клиент сначала подключится к серверу и представится. Затем сервер выделит новую пару _публикаций_ и _подписок_ \(которую мы называем _дуологией_ \) и сообщит клиенту, как с ними связаться. Клиент отключится, а затем подключится к новому _duologue_ и начнет посылать строки, которые будут отображаться, как раньше. Мы хотели бы добавить способ для сервера сигнализировать об ошибках клиенту, и, учитывая, что нам нужно выделять новые каналы для каждого нового клиента, мы бы посоветовали установить какое-то настраиваемое ограничение на количество клиентов, которые могут быть подключены в любой момент времени.

> Aeron предназначен для обслуживания сотен клиентов, а не тысяч. См. [System Design](https://github.com/real-logic/aeron/wiki/Best-Practices-Guide#system-design) для информации.

Правильный способ реализовать это, по-видимому, состоит в том, чтобы клиент представлял себя серверу на канале _всех клиентов_ , а затем сервер перенаправлял этого клиента к паре _публикация_ / _подписка,_ выделенной только для этого клиента. Сервер передает сообщения по _всем_ каналам _клиентов_ и префиксирует сообщения, адресованные конкретному клиенту, с _идентификатором сеанса_целевого клиента.

Когда клиент `c`подписывается на канал _всех клиентов_ , ему автоматически присваивается \(случайный\) _идентификатор сеанса_ `s` . Сервер выделяет новый дуолог `q`и передает сообщение, что клиент с сеансом `s`должен открыть _публикацию_ и _подписку_ на номер порта `q`. Затем клиент отписывается от канала _всех клиентов_ и открывает _публикацию_ и _подписку_ на номер порта `q`. Клиент и сервер могут затем обмениваться сообщениями один на один `q`с помощью сервера, удаляя его `q`при отключении клиента.

Разумеется, злонамеренный клиент может просто создать множество _подписок_ на канал _всех клиентов_и продолжать запрашивать новые _дуологи_ до _тех_ пор, пока на сервере не закончатся доступные порты UDP или не будет достигнуто максимальное количество клиентов для сервера. Поэтому необходимо просто отказаться от создания большего количества `n`новых _duologues_ для клиента на любом данном IP-адресе. Конечно, возникает еще одна проблема: что если клиент `c`подделывает бесконечный поток запросов для создания новых duologues, но делает это путем подмены IP-адреса другого клиента `d`в запросах? Сервер будет неправомерно наказывать `d`за запросы и фактически `d`не сможет запрашивать свои собственные_дуологи_ .

Для борьбы с обоими этими вопросами, сервер будет _истекать_ в _дилогия_ , если ни один клиент не подключен к нему в течение настраиваемого периода времени. Конечно, злонамеренный клиент может попытаться запросить максимальное количество _дуологов_ , подделав запросы и выдав себя за себя `d`, а затем может подделать дополнительные пакеты, подключиться к этим _дуологам_ и предотвратить их истечение срока действия. Это, по сути, заблокирует `d`сервер, пока сервер продолжает работать. Это трудно, но не невозможно для решительного нападающего. Чтобы бороться с этим, сервер должен затруднить кому-либо, кроме клиента с хорошим поведением, фактическое соединение с запрошенным _дуологом_, По сути, сервер должен делиться секретом с запрашивающим клиентом, и этот клиент должен затем представить этот же секрет серверу при подключении к _дуологу_ .

Решение этого довольно простое. Клиент отправляет 4-байтовый [Шифр Вернама](https://ru.wikipedia.org/wiki/%D0%A8%D0%B8%D1%84%D1%80_%D0%92%D0%B5%D1%80%D0%BD%D0%B0%D0%BC%D0%B0) на сервер, когда он подключается к каналу _всех клиентов_ . Согласно нашим [требованиям безопасности](security-requirements.md), только сервер способен считывать этот одноразовый шифр. Когда сервер создает новый _дуолог_ , он _заблаговременно_ выбирает _идентификатор сеанса_ для _дуолога_ \(вместо того, чтобы позволить Aeron выбирать его сам\), шифрует этот _идентификатор сеанса_ с помощью одноразовой панели клиента и отправляет зашифрованный идентификатор как часть ответ, данный клиенту при направлении его на новый _дуолог_ . Клиент расшифровывает _идентификатор сеанса_а затем использует его при подключении к _дуологу_ . Aeron автоматически отклонит любой клиент, который пытается подключиться с неверным _идентификатором сеанса_ ; нет необходимости иметь дело с недопустимыми сеансами на уровне приложения.

> Строго говоря, сервер не «отклоняет» клиента на основе идентификатора сеанса. Просто приложение указывает, что оно не заинтересовано в пакетах с чем-либо, кроме заданного _идентификатора сеанса,_ и поэтому никогда не видит пакеты, которые не принадлежат этому сеансу.

По сути, это означает, что злонамеренный клиент, который пытается помешать подключению другого клиента, должен:

1. Прослушайте сообщения в канале _всех клиентов,_ указывающие, что сервер только что создал новый _дуолог_ .
2. Как-то угадать исходный IP-адрес клиента, который создал _дуолог_ . В случае IPv4 это будет связано с угадыванием правильного адреса из нескольких `2 ^ 31`адресов.
3. Как-то угадать требуемый _идентификатор сессии_ . Идентификаторы выбираются случайным образом из пула `2 ^ 31`возможных значений.
4. Поддавать достаточно пакетов, реализующих базовый протокол Aeron, чтобы настроить требуемую публикацию в _duologue_ , включая трудно угадываемый _идентификатор сеанса_ , а затем подделывать больше пакетов, чтобы поддерживать соединение живым.

Казалось бы, этого почти невозможно достичь надежно. Для злоумышленника было бы проще предпринять некую распределенную атаку типа «отказ в обслуживании» \(против которой, очевидно, невозможна защита на уровне протокола\).  


